🧾 Lektionsplanering – Måndag 5 maj 2025
⏰ Tid: 09.00–12.00
🎯 Fokus: relationsdatabaser, SQL-syntax och CRUD med PostgreSQL & pgAdmin.
🧠 Pedagogiskt fokus: visa verktyg & syntax först – låt studenterna sen snabbt jobba praktiskt

-----------------------------
🎯 Syfte

Förstå vad en relationsdatabas är

Kunna skriva SQL-frågor för SELECT, INSERT, UPDATE, DELETE

Använda WHERE, ORDER BY och LIMIT

Skapa och hantera databaser i pgAdmin

-----------------------------
🧠 Agenda

09.00–09.15	👋 Intro & teori	"Vad är en databas? Vad är SQL?" (utan slides – muntlig walkthrough + whiteboard/texteditor)
09.15–10.15	💻 Code-Along del 1	Installera PostgreSQL & pgAdmin, skapa DB, tabell, INSERT, SELECT, UPDATE, DELETE
10.15–10.25	☕ Paus	
10.25–11.15	💻 Code-Along del 2	WHERE, ORDER BY, LIMIT – fler INSERTs, SELECT med filter och sortering
11.15–11.55	🧑‍💻 Självständig övning	Skapa egen databas, tabell, göra CRUD och filtreringar
11.55–12.00	🔁 Reflektion	3 min individuell reflektion + diskussionsrunda: “Vad var klurigt? Vad känns självklart?”

-----------------------------
🧠 TEORI – TALARMANUS (utan slides)

🗣️ Vad är en databas?

"En databas är som ett kalkylblad, men mycket kraftfullare. Den kan lagra, filtrera, sortera och koppla data – ofta i mycket stora mängder. PostgreSQL är ett exempel på en så kallad relationsdatabas, där vi organiserar data i tabeller med kolumner och rader."

🗣️ Vad är SQL?

"SQL är ett språk för att prata med databaser. Vi använder det för att fråga efter data (SELECT), lägga till data (INSERT), ändra (UPDATE) eller ta bort (DELETE)."

🗣️ Varför relationsdatabas?

"När vi har strukturerad data som har relationer – t.ex. användare och deras produkter – så är relationsdatabaser ett bra val. De ger tydlighet och kontroll."

-----------------------------
-----------------------------
-----------------------------
💻 CODE-ALONG: Del 1 – Setup & CRUD

1. Installera & starta PostgreSQL/pgAdmin

🛠️ Visa hur man laddar ner PostgreSQL och startar pgAdmin.
Skapa en databas lektiondb.

2. Skapa tabell users
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(50)
);

3. INSERT (lägg till data)
INSERT INTO users (name, email) VALUES ('Anna', 'anna@test.se');
INSERT INTO users (name, email) VALUES ('Erik', 'erik@test.se');

4. SELECT (läs data)
SELECT * FROM users;

5. UPDATE (ändra data)
UPDATE users SET name = 'Anna Svensson' WHERE id = 1;

6. DELETE (ta bort data)
DELETE FROM users WHERE id = 2;

-----------------------------
💻 CODE-ALONG: Del 2 – Filtrera & sortera

7. WHERE
SELECT * FROM users WHERE name = 'Anna Svensson';

8. ORDER BY
SELECT * FROM users ORDER BY name ASC;

9. LIMIT
SELECT * FROM users LIMIT 1;

💡 Visa exempel där ORDER BY + LIMIT kombineras:
SELECT * FROM users ORDER BY id DESC LIMIT 1;

-----------------------------
📚 Viktiga extra begrepp du kan lyfta i diskussion

SERIAL (auto-increment id)

VARCHAR (maxlängd på text)

INTEGER (heltal)

PRIMARY KEY (unik identifierare)

FOREIGN KEY (relation mellan tabeller)

JOIN (kombinera flera tabeller)

Pool från pg (effektiv hantering av anslutningar)
/ client vad är skillnaden?

-----------------------------

🗣️ Talarmanus:
"Varför behöver vi tabeller och kolumner?
Tänk er en Excel-fil med flera blad. Varje blad motsvarar en tabell i databasen, och varje kolumn definierar vad som sparas, t.ex. namn eller e-post. Varje rad är en enskild användare."

-----------------------------
Grundläggande SQL-queries (CRUD)

Operation	SQL Keyword	Förklaring
Create	INSERT	Lägg till data
Read	SELECT	Hämta data
Update	UPDATE	Ändra befintlig data
Delete	DELETE	Ta bort data

📌 INSERT (Lägg till data)
INSERT INTO users (name, email) VALUES ('Anna', 'anna@test.se');
INSERT INTO products (name, price) VALUES ('Laptop', 12000);

📌 SELECT (Läs data)
SELECT * FROM users;
SELECT name, price FROM products;

📌 UPDATE (Uppdatera data)
UPDATE users SET name='Anna Svensson' WHERE id=1;
UPDATE products SET price=10000 WHERE id=1;

📌 DELETE (Ta bort data)
DELETE FROM users WHERE id=1;
DELETE FROM products WHERE id=1;

-----------------------------
🔗 Relationshantering (Foreign keys)

📖 Förklaring & syfte
Relationsdatabaser använder nycklar (keys) för att koppla ihop data från olika tabeller.

Primary key: Unik identifierare för varje rad.

Foreign key: Hänvisning till primary key i en annan tabell.

🗣️ Talarmanus:
"Varför relationer?
Föreställ er att vi har användare och deras produkter. Vi vill veta vem som äger vilken produkt. Med en foreign key kan vi koppla produkten till användaren utan att duplicera användardata."

⚙️ Execute:
Skapa tabellen products:
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50),
  price INTEGER
);

"Här skapade vi tabellen products med en foreign key (user_id) som pekar på användarnas id."

Nu har vi användare och produkter, men hur kopplar vi ihop dem? Vi gör detta genom att lägga till en så kallad foreign key. Det betyder att varje produkt kan kopplas till en användare.

⚙️ Execute stegvis i pgAdmin:
ALTER TABLE products ADD COLUMN user_id INTEGER;
ALTER TABLE products ADD FOREIGN KEY (user_id) REFERENCES users(id);

Första raden lägger till en ny kolumn (user_id).

Andra raden definierar relationen där varje produkt hänvisar till ett användar-id.

-----------------------------
5. Skapa relationer mellan tabeller (JOIN-exempel)

JOIN används för att kombinera data från flera tabeller.

Typ av JOIN	Beskrivning
INNER JOIN	Visar rader där båda tabeller matchar.
LEFT JOIN	Visar alla rader från vänster tabell.
RIGHT JOIN	Visar alla rader från höger tabell.

"Varför använder vi JOIN? Om vi har data i olika tabeller och vill visa dem ihop, som produkter med deras ägares namn, behöver vi en JOIN."

⚙️ Execute JOIN-query (INNER JOIN):
SELECT products.name, products.price, users.name AS owner
FROM products
JOIN users ON products.user_id = users.id;

"Denna JOIN visar alla produkter och vem som äger dem."

-----------------------------
-----------------------------
-----------------------------
🧑‍💻 SJÄLVSTÄNDIG ÖVNINGAR

-----------------------------
-----------------------------
-----------------------------
🔁 Gruppdiskussion 

Vilka utmaningar mötte ni med SQL-syntax?

Hur skiljer sig SQL- och NoSQL-databaser i praktiken?

Hur ser ni på databasstruktur i ert Chas Challenge-projekt?

Vad är fördelen med SQL jämfört med NoSQL?

Vad tycker ni är svårast med SQL-syntax?

Varför är det viktigt med felhantering vid databasoperationer?