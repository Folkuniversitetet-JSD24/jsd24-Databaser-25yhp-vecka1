üß© Sj√§lvst√§ndiga √∂vningar 

üü¢ L√§tt niv√•

- L√§s fr√•n databas med JOIN + json_agg

Scenario:
Du ska h√§mta alla anv√§ndare tillsammans med deras registrerade kurser.

Uppgift:
1. Anv√§nd GET /users-endpointen du byggt.

2. F√∂rklara vad json_agg g√∂r och hur GROUP BY anv√§nds i din kod.

3. L√§gg till en ny anv√§ndare i Postman med 2 kurser, t.ex. med courseIds: [1, 2].

4. Bekr√§fta resultatet i Postman och pgAdmin (i junction-tabellen user_courses).

--------------------------------
‚Äì Kontrollera inneh√•llet i junction-tabellen

Uppgift:
1. √ñppna pgAdmin och v√§lj user_courses

2. V√§lj "View/Edit Data ‚Üí All Rows"

3. Besvara:
    - Hur m√•nga kopplingar finns?
    - Vilka user_id har kurs_id 1?

4. G√∂r samma kontroll i Postman med GET /users ‚Äì st√§mmer datan?

üß† Syfte: F√• f√∂rst√•else f√∂r hur en many-to-many-relation faktiskt lagras och visualiseras.

--------------------------------
--------------------------------
--------------------------------
üü† Medel niv√•

1. Bygg en ny endpoint med JOIN

Scenario:
Du vill kunna h√§mta alla kurser, och f√∂r varje kurs se vilka anv√§ndare som √§r registrerade.

Uppgift:
1. Skapa en ny GET-endpoint: GET /courses/full

2. Skriv en SQL-fr√•ga som anv√§nder json_agg(users.*) f√∂r att gruppera anv√§ndare per kurs.

3. Testa att k√∂ra anropet i Postman och s√§kerst√§ll att det returnerar kurser och tillh√∂rande anv√§ndare i JSON-format.

Bonus:
Visa resultatet i pgAdmin ‚Äì vilka anv√§ndare √§r kopplade till respektive kurs?

--------------------------------
2. Uppdatera en anv√§ndares e-post

Scenario:
En anv√§ndare har bytt e-post och du vill uppdatera den i databasen.

Uppgift:
    - L√§gg till en ny endpoint: PUT /users/:id
    - Endpointen ska uppdatera namn och e-post f√∂r en anv√§ndare baserat p√• req.body
    - Skriv SQL-fr√•ga med UPDATE users SET ... WHERE id = $1
    - Testa i Postman:
    PUT /users/1
{
  "name": "Student Studentsson",
  "email": "Student.Studentsson@example.com"
}

    - Verifiera √§ndringen i pgAdmin

üß† Syfte: Tr√§na UPDATE och att kombinera Express + SQL

--------------------------------
--------------------------------
--------------------------------
üî¥ Sv√•r niv√•

1. L√§gg till DELETE med transaktion

Scenario:
Du vill ta bort en anv√§ndare OCH samtidigt ta bort kopplingen till kurser i samma transaktion.

Uppgift:
- Skapa en DELETE-endpoint: DELETE /users/:id

- I funktionen:
    1. Anv√§nd BEGIN
    2. Ta f√∂rst bort poster i user_courses f√∂r anv√§ndaren
    3. Ta sedan bort anv√§ndaren fr√•n users
    4. Anv√§nd COMMIT
    5. Vid fel, g√∂r ROLLBACK

- Bekr√§fta att det fungerar via Postman och pgAdmin.

--------------------------------
‚Äì Bygg en GET /users/:id

Scenario:
Du vill kunna visa detaljerad information om en specifik anv√§ndare, inklusive kurser.

Uppgift:
    - Skapa ny route: GET /users/:id
    - SQL-fr√•gan ska h√§mta anv√§ndaren med tillh√∂rande kurser via json_agg(...)
    - Returnera struktur:
{
  "id": 1,
  "name": "Student",
  "email": "Student@example.com",
  "courses": [
    { "id": 1, "title": "JavaScript", ... },
    { "id": 2, "title": "Node.js", ... }
  ]
}
    - Testa i Postman med olika id

üß† Syfte: Djupare f√∂rst√•else f√∂r parameterhantering, SQL-f√∂rfining och exakt data√•tkomst

-------------------------------
-------------------------------
-------------------------------
üîÅ Gruppdiskussion 

Vad √§r en transaktion och varf√∂r anv√§nds BEGIN/COMMIT/ROLLBACK?

Vad √§r f√∂rdelen med many-to-many-relationer j√§mf√∂rt med one-to-many?

Hur hj√§lper JOIN oss att kombinera data fr√•n flera tabeller?

Vilka utmaningar finns med many-to-many relationer?

N√§r √§r det bra att anv√§nda subqueries vs JOINs?